# Worksheet J4 
## Question 1.
The declaration does not work because a class can only direclty extend one other class. The word keyword extends can only have one argument. This task can be acomplished by having Carnivore be a interface rather than a class, and have the Lion class implement it rather than extend it. 
## Question 2. 
An interface defines only methods that need to be implemented, it cannot be instatiated and all methods are abstract. Abstract classes can contain concrete and abstract methods. One class can implement multiple interfaces, but can only extend one abstract class. 

## Question 3.
``` java 
 public void push(int v) {
    this.addToFront(v);
  }

  public int pop() {
    return this.rmFromFront();
  }

  public int peek() {
    return this.rmFromFront(); 
  }

  public void enqueue(int v) {
    this.addToBack(v);
  }

  public int dequeue() {
    return this.rmFromFront();
  }
```

## Question 4.
```java
public interface Stack<T> {
   public void push(T t);
   public T pop();
   public T peek();
}

public interface Queue<T> {
   public void enqueue(T t);
   public T dequeue();
   public T peek();
}
```

```java
public class LinkedList<T> implements Stack<T>, Queue<T> {
  public LinkedList<T>() {/*...*/}
  public void addToFront(T t) {/*...*/}
  public T rmFromFront() {/*...*/}
  public void addToBack(T t) {/*...*/}
  public void rmFromBack() {/*...*/}
  
  //FINISH HERE
   public void push(T t) {
    this.addToFront(t);
  }

  public T pop() {
    return this.rmFromFront();
  }

  public T peek() {
    return this.rmFromFront(); 
  }

  public void enqueue(T t) {
    this.addToBack(t);
  }

  public T dequeue() {
    return this.rmFromFront();
  }
  
}

```

## Question 5.
```java
import java.util.HashMap;

public class TestHashMap {

    public static void main (String[] argv) {
        // Create a new hashmap.
        HashMap<String, String> fabFour = new HashMap<>();

        // Insert four key and value pairs.
        fabFour.put("John", "John Lennon");
        fabFour.put("Paul", "Paul McCartney");
        fabFour.put("George", "George Harrison");
        fabFour.put("Ringo", "Ringo Star");

        // Use a key to retrieve a value.
        String fullName = fabFour.get("Ringo");

        // Prints "Ringo Star"
        System.out.println(fullName);
    }
}
```

## Question 6.
Erasure with java generics is the idea that, at compile time, any generic type will be substituted by the type argument. In the example code, when Shelf object is created everywhere the type was generic it becomes an String.

## Question 7. 
```java
public class TestShelf {
    public static void main(final String args[]) {

        // TODO: Create a shelf to store Shakespeare character names:
        //       Hamlet, Othello, Cordelia, and Juliet
        Shelf<String> testShelf = new Shelf<String>("Shakespeare Characters");
        testShelft.addItem("Hamlet");
        testShelft.addItem("Othelo");
        testShelft.addItem("Coderlia");
        testShelft.addItem("Juliet");
        // TODO: Then print the shelf.
        testShelf.printShelf()


        // TODO: Create a shelf to store famous integers:
        //       13, 23, 42, 1729,
        Shelf<Integer> testShelf2 = new Shelf<Integer>("Famous Integers");
        testShelf2.addItem(13);
        testShelf2.addItem(23);
        testShelf2.addItem(42);
        testShelf2.addItem(1729);
        // TODO: Then print the shelf.
        testShelf2.printShelf();

    }
}
```

## Question 8.
the method .get() is likely a O(n) method, and it is inside an O(n) algorithm, resulting in O(n^2) to run that part of the code. In this case, a simple iteration to print the list should have been done in O(n).

## Question 9.
Having a LinkedList class that implements Iterable will enable the for each iteration of the LinkedList which will use the following code under the hood:
```java
   while(iter.hasNext()) { //Iterator interface
      String s = iter.next(); //Iterator interface
   /*...*/
}
```
Which take O(n)

## Question 10.
Comparable is an interface rather than a class because its intention is to establish the framework within a class to make it able to compare objects. 


## Question 11.
```java
public int compareTo(Car other){
      ts = this.topSpeed;
      os = other.topSpeed;
      if(os == ts){
        return 0;
      }
      else if(os > ts){
        return -1;
      }
      else{
        return 1;
      }
}
```




